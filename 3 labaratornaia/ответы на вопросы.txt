1. Назовите принципы ООП. Поясните каждый из них. 
Инкапсуляция (пакетирование)
►механизм, связывающий вместе данные и
код, обрабатывающий эти данные, и
сохраняющий их от внешнего
воздействия и ошибочного использования
Свойства инкапсуляции
►Совместное хранение данных и функций
►Сокрытие внутренней информации от
пользователя
►Изоляция пользователя от особенностей
реализации
-------------------------------------------------
Абстракция подразумевает разделение и
независимое рассмотрение интерфейса
и реализации
►абстракция - уровень
описания/представления модели чего
либо
----------------------------
Наследование
►процесс, благодаря которому один объект
может наследовать (приобретать)
свойства от другого объекта.
►иерархии классов
Student -> GradStudent
------------------
Полиморфизм
► -способность вызывать метод потомка через
экземпляр предка
► - способность программы идентично
использовать объекты с одинаковым
интерфейсом без информации о конкретном
типе этого объекта
Поддержка полиморфизма осуществляется через
виртуальные функции, механизм перегрузки
функций и операторов, а также обобщения



2. Назовите класс .NET, от которого наследуются все классы.
System
----

3. Охарактеризуйте открытые методы System.Object
ToString
►cлужит для получения строкового
представления объекта
►Для классов - выводит полное название
класса с указанием пространства имен, в
котором определен этот класс.
►ToString можем переопределить

Метод Equals
Равенство и тождество объектов

стандартная реализация метода Equals типа Object
реализует проверку на тождество

►Корректная реализация 
в качестве параметра принимает
объект любого типа, который
приводим к текущему

Требования к Equals
►Рефлексивность:
 x.Equals(x)  true
►Симметричность:
 x.Equals(y) и y.Equals(x)  результат одинак.
►Транзитивность:
 x.Equals(y) - true
 y.Equals(z) – true
 x.Equals(z)  true
►Постоянство:
 не должен измениться если не изменился
объект 


GetHashCode
Хеш-коды объектов
►Переопределяется GetHashCode и Equals
(парой)
При реализации типов
System.Collections.Hashtable,
System.Collections.Generic.Dictionary и других
коллекций требуется, чтобы два равных
объекта имели одинаковые значения хеш-кодов
Требования к GetHashCode
►Случайное распределение
►Не использовать GetHashCode для Object
или ValueType (низкая производительность
алгоритмов хеширования)
►Использовать экземплярные поля
►Максимально быстрый
►Объекты с одинаковым значением
должны возвращать одинаковые коды

метод GetType
►позволяет получить тип данного объекта


Finalize()
► деструктор - вызывается при сборке мусора
для очистки ресурсов, занятых ссылочным
объектом
► Реализация из Object игнорируется сборщиком
мусора
► Переопределяется если объект владеет
неуправляемыми ресурсами, которые нужно
освободить при его уничтожении


Clone()
►создает копию объекта и возвращает
ссылку на эту копию (неглубокое)
►неглубокое копирование - копируются
все типы значений в классе, копируются
только ссылки, а не объекты, на которые
они указывают
►не виртуальный, переопределять его
реализацию нельзя


4. Охарактеризуйте закрытые методы System.Object.
Object.MemberwiseClone Method
Создает поверхностную копию текущего объекта .
5. Приведите пример определения класса.
[ атрибуты ] [ спецификаторы ]
class имякласса [ : предок ]
{
тело-класса
}

6. Какие ключевые слова можно использовать при определении класса?
virtual, new,
override, sealed и abstract
--
public private protected internal


7. В чем отличие между объектом и классом?
структурированная

объект- переменная, содержащая
всю информацию о
некотором физическом
предмете или реализуемом в
программе понятии.

класс - множества таких
объектов и
выполняемых над
ними действий.

►Класс – это некоторое абстрактное понятие
- шаблон, по которому определяется
форма объекта
►Объект – это физическая реализация
класса(шаблона).


8. Что такое конструктор? Когда вызывается конструктор?

Конструкторы — это специальные методы,
позволяющие корректно инициализировать новый
экземпляр типа.


Конструктор - это специальный метод, который вызывается при создании нового объекта. 
Не всегда удобно инициализировать все переменные класса при создании его экземпляра. 
Иногда проще, чтобы какие-то значения были бы созданы по умолчанию при создании объекта.


9. Перечислите свойства конструктора?

Свойства конструкторов
► 1) имя такое же как и имя типа (класса )
► 2) не имеет возвращаемого значения
► 3) не наследуются
► 4) нельзя применять модификаторы virtual, new,
override, sealed и abstract
► 5) для класса без явно заданных конструкторов
компилятор создает конструктор по умолчанию (без
параметров)


10. Что такое деструктор (destructor) ?
Деструкторы
► вызываться непосредственно перед
окончательным уничтожением объекта
системой "сборки мусора", чтобы гарантировать
четкое окончание срока действия объекта.
~имя_класса () { // код деструктора }

11. Что такое this?
) можно явно заставлять один конструктор
вызывать другой конструктор посредством
зарезервированного слова this
►обеспечивает доступ к текущему
экземпляру класса
► в любой нестатический метод автоматически
передается скрытый параметр this

12. Что будет выведено в результате выполнения
class A
 {
 private int _num;
 public A(int num) { Num = num; }
 public int Num { get { return _num; } set { _num = value; } }
 }
 static void Main(string[] args)
 {
 A a = new A(5);
 A b = a;
 Console.WriteLine(a.Num + " " +b.Num);

 a.Num = 7;
 Console.WriteLine(a.Num + " " + b.Num);
 }

5 + 5 
7 + 7


13. Какие спецификаторы доступа для класса и методов класса существуют в
C#?
 public - доступ не ограничен – все члены во
всех сборках
► private - по умолчанию для членов
класса (используется для вложенных классов).
Доступен только методам в определяющем
типе и вложенных в него типах
► protected - (используется для вложенных
классов) Доступен только методам в
определяющем типе (и вложенных в него
типах) или в одном из его производных типов
независимо от сборки
► internal - доступ только из данной сборки


14. Опишите модификатор protected internal
► protected - (используется для вложенных
классов) Доступен только методам в
определяющем типе (и вложенных в него
типах) или в одном из его производных типов
независимо от сборки
► internal - доступ только из данной сборки


15. Зачем и как используются ref и out параметры функции?
Модификаторы параметров
методов
для обмена данными между вызывающей и вызываемой
функциями предусмотрено четыре типа параметров:
►По умолчанию- параметры-значения;
► параметры-ссылки — ref;
► выходные параметры-ссылки — out:
► переменное количество — params (один
и последний).
Назначение:
► позволить методу менять содержимое
его аргументов
► возвращать более одного значения

----

►ref заставляет С# организовать вместо
вызова по значению вызов по ссылке
Аргументу, передаваемому методу "в сопровождении"
модификатора ref, должно быть присвоено значение до
вызова метода. 


out
►Модификатор out подобен модификатору
ref за одним исключением:
его можно использовать для передачи
значения из метода
out-параметр "поступает" в метод без
начального значения, но метод (до
своего завершения) обязательно
должен присвоить этому параметру
значение

16. Приведите пример необязательных и именованных параметров метода

Необязательные аргументы
► позволяет определить используемое по
умолчанию значение для параметра метода
► можно применять в конструкторах,
индексаторах


Необязательные параметры
По умолчанию при вызове метода необходимо предоставить значения для всех его параметров. Но C# также позволяет использовать необязательные параметры. Для таких параметров нам необходимо объявить значение по умолчанию. Также следует учитывать, что после необязательных параметров все последующие параметры также должны быть необязательными:

static int OptionalParam(int x, int y, int z=5, int s=4)
{
    return x + y + z + s;
}
Так как последние два параметра объявлены как необязательные, то мы можем один из них или оба опустить:


static void Main(string[] args)
{
    OptionalParam(2, 3);
 
    OptionalParam(2,3,10);
 
    Console.ReadKey();
}



Именованные параметры
В предыдущих примерах при вызове методов значения для параметров передавались в порядке объявления этих параметров в методе. Но мы можем нарушить подобный порядок, используя именованные параметры:

static int OptionalParam(int x, int y, int z=5, int s=4)
{
    return x + y + z + s;
}
static void Main(string[] args)
{
    OptionalParam(x:2, y:3);
     
    //Необязательный параметр z использует значение по умолчанию
    OptionalParam(y:2, x:3, s:10);
 
    Console.ReadKey();
}

17. Приведите пример полей класса – статические, константные, только для
чтения. 

class Point
{
public int x;
public readonly int y = 0; // можно так инициализировать
public Point (int _y)
{
y = _y; //может быть инициализировано
} //или изменено в конструкторе после компиляции
public void ChangeY(int _y)
{
y = _y; // нельзя
}
}
--------------------

class Account
{
    public Account(decimal sum, decimal rate)
    {
        if (sum < MinSum) throw new Exception("Недопустимая сумма!");
        Sum = sum; Rate = rate;
    }
    private static decimal minSum = 100; // минимальная допустимая сумма для всех счетов
    public static decimal MinSum
    {
        get { return minSum; }
        set { if(value>0) minSum = value; }
    }
 
    public decimal Sum { get; private set; }    // сумма на счете
    public decimal Rate { get; private set; }   // процентная ставка
 
    // подсчет суммы на счете через определенный период по определенной ставке
    public static decimal GetSum(decimal sum, decimal rate, int period)
    {
        decimal result = sum;
        for (int i = 1; i <= period; i++)
            result = result + result * rate / 100;
        return result;
    }
}

------

namespace ConsoleApp2
{
  // Класс, реализующий вычисление площади различных фигур
  class CircleFigures
  {
    // константное поле - изменить в классе нельзя
    public const double Pi = 3.141592; // неявно считается статическим

    // метод, вычисляющий длину окружности заданного радиуса
    public double Length(double radius)
    {
      // используется внутренняя константа Pi
      return 2 * Pi * radius;
    }

    // метод, вычисляющий площадь окружности заданного радиуса
    public double Area(double radius)
    {
      // используется внутренняя константа Pi
      return Pi * radius * radius;
    }


18. Приведите пример определения свойств класса. Как свойства связаны с
инкапсуляцией?
можно назначить метод доступа свойству
class StudentBSTU
{
private string name;//свойство
public string Name
{
get
{
return name;
}
set
{
name = value;
}
}
}

(читать про инкапсуляцию)

19. Назовите явное имя параметра, передаваемого в метод set свойства класса?
value. Тип этого параметра определяется типом свойства.
20. Что такое автоматические свойства?
Автоматические свойства
тип имя { get; set; }
компилятор автоматически реализует методы для
правильного возвращения значения из поля и
назначения значения полю
Проблемы:
• неявная инициализация
• проблемы при сериализации и десериализации
• во время отладки нельзя установить точку
останова
компилятор автоматически генерирует при
компиляции поля для свойств
21. Что такое индексаторы класса? Какие ограничения существуют на
индексатор?
Индексаторы (свойства с параметрами)
►Позволяют индексировать объекты таким
же способом, как массив или коллекцию
►«умный» индекс для объектов
►средство, позволяющее разработчику
перегружать оператор []
атрибуты спецификаторы тип this
[ список_параметров ]
get код доступа
set код доступа

Ограничения на индексаторы:
1) значение, выдаваемое индексатором,
нельзя передавать методу в качестве
параметра ref или out
2) индексатор не может быть объявлен как
static

22. Что такое перегруженный метод?
Иногда возникает необходимость создать один и тот же метод, но с разным набором параметров. 
И в зависимости от имеющихся параметров применять определенную версию метода. 
Такая возможность еще называется перегрузкой методов (method overloading).

Перегрузка методов
►один и тот же метод, но с разным
набором параметров
► позволяет обращаться к связанным
методам посредством одного, общего для
всех имени.
► никакие два метода внутри одного и того
же класса не должны иметь одинаковую
сигнатуру
сигнатура (signature) = имя метода + список его
параметров (не включает тип значения,
возвращаемого методом, не включает paramsпараметр)

23. Что такое partial класс и какие его преимущества?
Частичные классы
структуры, интерфейсы и методы
Назначение:
► Управление версиями
► Разделение файла или структуры на логические модули
► Использование шаблонов (авто генерируемый код)
Правила использования частичных
методов
► внутри частичного класса или структуры
► должны всегда иметь возвращаемый тип void
► не могут иметь параметров out
► может иметь параметры ref, универсальные
параметры, экземплярные или статические,
unsafe
► private не пишется (закрыт)

24. Что такое анонимный тип в C#?
Анонимные типы
► позволяют создать объект с некоторым
набором свойств без определения класса (тип в
одном контексте или один раз).
var someType = new {Name = "Anna"};


25. Для чего делают статические классы?
Статический класс
► прямой потомок System.Object
► экземпляры такого класса создавать запрещено
► не должен реализовывать никаких интерфейсов
(не вызвать)
► нельзя использовать в качестве поля,
параметра метода или локальной переменной
► от него запрещено наследовать
► все элементы такого класса должны явным
образом объявляться с модификатором static
► может иметь статический конструктор
► Компилятор не создает автоматически
конструктор по умолчанию


26. В чем отличие статического поля от экземплярного?
статическое поле одно для всего класса 

27. Поясните работу статических конструкторов.
Статический конструктор используется для инициализации любых статических данных или для выполнения определенного действия, которое необходимо выполнить только один раз. 
Он вызывается автоматически перед созданием первого экземпляра или перед ссылками на статические члены.

28. Какая разница между поверхностным (shallow) и глубоким (deep)
копированием?

При поверхностном копировании копируются значения полей класса, включая значения любых указателей или ссылок.
 При этом скопированные значения этих указателей и ссылок указывают на одни и те же объекты, что и в оригинальном объекте, что зачастую ведет к ошибкам.
 Отсюда и название такого метода копирования: мы копируем только указатели/ссылки, вместо того, чтобы делать копии этих внутренних объектов и ссылаться на них, 
собственно не углубляемся во внутреннюю структуру объекта. При глубоком копировании мы копируем значения полей не только на первом "уровне", но и заходим глубже, копируя все значения.

Стоит дописать что для deep copy обьект должен определять метод Clone() интерфейса
ICloneable.

Если мы хотим скопировать обьект, который не содержит внутренних ссылок, то можно использовать this.memberwizeClone() (это и есть shallow copy). 
Если же есть внутренние ссылки на другие обьекты, то этого будет недостаточно, кроме вызова memberwizeClone() 
нужно будет вручную создавать новые екземпляры внутренних обьектов и присваивать значения обьекту вручную

29. В чем разница между равенством и тождеством объектов?
идентичность: переменная содержит тот же экземпляр, что и другая переменная.

равенство: два различных объекта могут использоваться взаимозаменяемо. у них часто один и тот же идентификатор.

30. Что такое частичные классы и частичные методы?
Когда вы определяете класс с помощью ключевого слова partial, вам или кому-либо другому разрешается ввести
 функциональные возможности класса с помощью другого класса, который также должен быть объявлен как partial. Это полезно в следующих ситуациях:

Когда у вас есть очень большой класс - вы можете сохранить его в нескольких файлах, чтобы облегчить работу с различными частями классов.
 Например, вы можете иметь все свойства в одном файле и все методы в другом файле, имея при этом только один класс.
При работе с конструктором, как в Visual Studio, например с WinForms, где весь автоматически сгенерированный
 код конструктора может храниться в одном файле, в то время как код хранится в другом файле.

Частичный класс или структура могут содержать частичный метод.

Частичные методы – это методы, где «прототип» или сигнатура метода определена при создании частичного класса, а реализация выполняется в любой другой (только одной) части этого класса.

Преимущество использования таких методов состоит в том, что их реализацию можно не выполнять. В таком случае, при компилировании кода данный метод даже не компилируется и не попадает в IL-код. То есть, как будто этот метод вообще не существовал.

Правила использования частичных методов:

Частичные методы должны быть определенны только в частичных классах.
Частичные методы должны быть помечены ключевым словом partial.
Частичные методы являются скрытыми (private), но явное использование с ними модификатора доступа приведет к ошибке.
Частичные методы должны возвращать void.
Частичные методы могут быть нереализованными.
Частичные методы могут не иметь аргументов.
Частичный метод может быть реализован только один раз.

31. Что будет выведено на консоль результате выполнения следующего кода:
System.Int32
32. Что будет выведено на консоль результате выполнения следующего кода:
a= 2 b= 1
  class MyClass
        {
            static void Main()
            {
                int a = 1, b = 2;
                change(ref a, ref b);
                Console.WriteLine("a= " + a + " b= "+ b);
                Console.ReadLine();
            }
            private static void change(ref int a, ref int b)
            {
                int c = a;
                a = b;
                b = c;
            }
     }
    
33. Пусть задан следующий класс
Какой из конструкторов задан неверно?
  internal class A
{
   // public A() { }
    public int A() { } 222222 ТИП
   // public A(int somel) { } 
    //public A(A somA) { }

}

34. Пусть задан следующий класс.
2 именованые
35. Почему не удается создать объект класса A?
потому что он находиться не вклассе
36. Что будет выведено в консоль при выполнении данной программы?
 class A
{
    static A() { Console.WriteLine("A static"); }
    public A() { Console.WriteLine("A "); }
}

   class Program
{
    static void Main() { new A(); }
}

a static
a

37. Какая строка приведенного далее класса вызовет ошибку компиляции?

 class Points
{
    public readonly int a = 10;
    public static readonly Int32 b = new Int32();
    public static string c = "New";
    private int d;

    public Points()
    {
        c = "Method";
        a = 20;
        b = 30;//эта т.к она наз-я d
    }
}

